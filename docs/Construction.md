# SIN Documentation

_Note: This document describes an aspect of the language which has not yet been implemented._

## Type Construction

In SIN, data may not be referenced before it is initialized, either with an assignment using `let` or with alloc-init syntax (e.g., `alloc int x: 10`). However, the compiler will not prevent you from doing something like the following:

    alloc int x;
    if (some_condition) {
        let x = 30;
    }
    alloc ptr<int> p: $x;
    alloc int y: *p;

What is the value of `y`? It depends on the truthiness of `some_condition`; if `true`, `y` will be equal to 30. But if not, then what _does_ `y` equal? In some languages, this might be undefined or maybe even illegal behavior. In this example, `y` is assigned with the value `x`, which has not been initialized. However, the compiler has no way of knowing whether a pointer is pointing to uninitialized data.

If `p`'s allocation had occurred immediately after `x`'s, then the compiler would have issued an error because `x` was _definitely_ left uninitialized. However, in this example, the SIN compiler will only issue a warning here, stating that `p` is being assigned the address of potentially uninitialized data, but it is not strictly illegal because of _default type construction._ In order to maintain data safety and preventing the use of garbage data, all data in SIN will be constructed to some default value if it is left uninitialized in the allocation. However, the compiler will still issue errors if some piece of uninitialized data is accessed (unless via a pointer). As such, following SIN's type construction rules, in the above example, `y` will be equal to 0.

The following is a table of default constructed values:

| Type | Default value |
| ---- | ------------- |
| All integral types | 0 |
| Pointers | `null` |
| All floating-point types | 0.0 |
| `string` | Empty string (a null byte) with length 0 |
| `char` | `\0` |
| Arrays, tuples, and structs | All members are constructed according to its type rules |

However, not all data may be legally default-constructed; some types must be initialized in their allocation:

* All data marked `const` must be initialized with a `constexpr`
* All references must supply the address of the referent using alloc-init syntax

### The `construct` keyword

Perhaps the most important aspect of default construction is when used with structs. Unlike, for example, Java, where default constructors are automatically generated by the compiler (if no other constructor is available), the SIN compiler does not provide any such method because _no_ methods exist for _any_ struct. This means that if a struct is allocated, and only some of its members are initialized, the struct itself will have been seen as initialized in the compiler when some of its fields may not have been. As an example, take the following example where we initialize some struct `point`, with integer members `x, y, z`:

    alloc point p;
    let p.x = 10;
    alloc int n: p.y;

In this case, the compiler will allow the use of `p.y` because it will consider the struct `p` as having been initialized -- it is not required to track every individual member. However, it is obvious that `p.y` will really be uninitialized. To solve this problem, SIN utilizes _type construction_ and allows for a Rust-like construction to be specified when a struct is allocated.

So, in the above example, we could say:

    alloc point p: construct point {
        x: 10,
        y: 0,
    };

Like in Rust, the `construct` expression must initialize _every_ member. However, since `construct` was not used in the initial example, the struct would have been default-constructed such that all members would be set equal to 0. If a struct contains reference members, it _must_ use alloc-init syntax; default construction of such structs is not allowed.

There are three scenarios where the `construct` keyword may be used:

* Initialization with alloc-init syntax
* Whole struct assignment or initialization
* Struct replacement via anonymous struct creation

The above example used alloc-init syntax. If a struct contains references, this will still work because a new struct is created that replaces the old one. For example, this code is valid:

    alloc int x: 10;
    alloc int y: 10;
    def struct m {
        alloc ref<int> r;
    }

    // alloc-init intialization
    alloc m m1: construct { // saying 'construct m' is not strictly necessary, 
                            // as it must obviously be constructing an object of type 'm'
        r: $x,
    };

    // whole struct assignment / initialization
    alloc point origin;
    construct origin {
        x: 0,
        y: 0,
        z: 0,
    };

    // struct replacement with an anonymous struct
    let m1 = construct point {
        r: $y,
    };

Typically, references are immutable, but in this instance, the entire struct `m1` is deleted and replaced with a new object. This means that we aren't really altering its references, we are replacing them. However, this means that we could _not_ do the following afterwards

    construct m1 {
        r: $x,
    };

because `r` has already been assigned as a reference to `y` and is now syntactically an integer. Utilizing `construct` can be used to assign all members of a struct, and so we _could_ say

    construct m1 {
        r: 50,
    };

This is because a `construct` _statement_ acts as a regular assignment if the data was already initialized; it does not create a new object. A `construct` _expression_ will create a new, anonymous object.
