/*

SIN Toolchain (x86 target)
member_selection.cpp
Copyright 2020 Riley Lannon

Implementation of the member_selection class

*/

#include "member_selection.h"

member_selection member_selection::create_unary_node(Unary& exp, struct_table& structs, symbol_table& symbols, unsigned int line) {
	/*

	create_unary_node
	Creates a unary node for the member_selection expression, utilizing recursion

	*/

	member_selection m;

	auto operand = exp.get_operand();
	if (operand->get_expression_type() == UNARY) {
		m = create_unary_node(*dynamic_cast<Unary*>(operand.get()), structs, symbols, line);
	}
	if (operand->get_expression_type() == BINARY) {
		m = create_member_selection(*dynamic_cast<Binary*>(operand.get()), structs, symbols, line);
	}
	else if (operand->get_expression_type() == IDENTIFIER) {
		m = create_lvalue_node(*dynamic_cast<Identifier*>(operand.get()), structs, symbols, line, exp.get_operator() == DEREFERENCE);
	}
	else {
		throw CompilerException("Illegal expression in member selection", compiler_errors::INVALID_EXPRESSION_TYPE_ERROR, line);
	}

	return m;
}

member_selection member_selection::create_lvalue_node(Identifier& exp, struct_table& structs, symbol_table& symbols, unsigned int line, bool is_pointer) {
	/*

	creatE_lvalue_node
	Creates a member_selection object from an lvalue

	*/
	
	member_selection m;

	// get the symbol information
	symbol* left_sym = dynamic_cast<symbol*>(symbols.find(exp.getValue()).get());
	auto t = left_sym->get_data_type();
	if (
		(!is_pointer && t.get_primary() != STRUCT) ||
		(is_pointer && t.has_subtype() && t.get_subtype().get_primary() != STRUCT)
	) {
		throw CompilerException("Expected left-hand argument of 'struct' type", compiler_errors::STRUCT_TYPE_EXPECTED_ERROR, line);
	}

	// add the symbol to our list
	m.append(*left_sym);
	return m;
}



std::stringstream member_selection::evaluate(symbol_table &symbols, struct_table &structs, unsigned int line) {
	/*

	evaluate_dot
	Generates code to evaluate an expression that uses the dot operator (e.g., "p.a")

	This function utilizes the member_selection class to create a chain of symbols (in a doubly-linked list, implemented by std::list) in the selection expression.
	This list allows us to perform type checks and ensure any dereferences are handled properly. Further, it allows code generation *after* the selection tree is fully parsed.

	If the program contains the following code:
		(*a).b
	the create_member_selection algorithm will generate something like
		{ a, struct, some_struct_name } -> { b, int }
	However, when the algorithm looks up a in the symbol table, it will see
		{ a, ptr < struct, some_struct_name > }
	for the symbol data; this means it must have been dereferenced. As such, it will generate code to dereference and then check for symbol equality again.
	Note that create_member_selection will check Dereferenced expression types to ensure the dereference is actually legal

	After the code generated by this function, the address of the desired data will be in RBX (this allows for both assignment

	@param	dot_exp	A reference to the expression where the members are being selected
	@param	m	The member_selection object we have generated for the expression
	@param	line	The line where this selection occurs

	@returns	A stringstream containing the generated code

	*/

	std::stringstream eval_ss;

	// the first symbol is a special case because it is going to be in the symbol table as an individual entry
	symbol current_node = this->first();
	
	// since it's the first symbol, it must be in the compiler's symbol table
	symbol& table_entry = *dynamic_cast<symbol*>(symbols.find(current_node.get_name()).get());
	DataType entry_type = table_entry.get_data_type();	// this will be updated, so do not use a reference

	// move the address into RBX; if it is a pointer type (but not 'dynamic'), this will be handled in a second -- this will move the address of the *pointer* into memory, and the actual address will be fetched if necessary
	if (entry_type.get_qualities().is_dynamic()) {
		// dynamic memory and pointers fetch the data at the offset
		eval_ss << "\t" << "mov rbx, [rbp - " << table_entry.get_offset() << "]" << std::endl;
	}
	else if (entry_type.get_qualities().is_static()) {
		// static memory utilizes the name
		eval_ss << "\t" << "mov rbx, " << table_entry.get_name() << std::endl;
	}
	else {
		// automatic memory
		eval_ss << "\t" << "lea rbx, [rbp - " << table_entry.get_offset() << "]" << std::endl;
	}

	// now, step through the member_selection object, fetching each from the _previous_ struct's symbol table
	current_node = this->next();
	bool done = false;

	// note we want to compare the *identity* of the symbols because we always use references
	while (!done) {
		// ensure the previous type is 'struct'
		// note that since dereferences were parsed out by member_expression, we should check the pointed-to struct type
		DataType t = this->peek_previous().get_data_type();
		while (t.get_primary() == PTR) {
			// get the address of the struct in RBX
			eval_ss << "\t" << "mov rbx, [rbx]" << std::endl;
			t = t.get_subtype();
		}
		if (t.get_primary() != STRUCT) {
			throw CompilerException("Expected left-hand argument of struct type", compiler_errors::STRUCT_TYPE_EXPECTED_ERROR, line);
		}

		// fetch the struct data of the previous symbol
		struct_info& s = structs.find(t.get_struct_name(), line);	// this function throws an exception if the struct hasn't been defined
		
		// now, get the symbol for the struct member
		symbol& member_data = s.get_member(current_node.get_name());
		DataType member_data_type = member_data.get_data_type();

		// now that the address is in RBX, update our offset (as long as it isn't 0 -- else, no point in updating it)
		if (member_data.get_offset() != 0)
			eval_ss << "\t" << "add rbx, " << member_data.get_offset() << std::endl;

		// if the types don't match, ensure we have pointers and continue updating until we have sufficiently dereferenced the symbol
		while (current_node.get_data_type() != member_data_type) {
			eval_ss << "\t" << "mov rbx, [rbx]" << std::endl;
			member_data_type = member_data_type.get_subtype();
		}

		// update the current node; if we can't, then we are done
		if (this->is_at_end()) {
			done = true;
		}
		else {
			current_node = this->next();
		}
	}

	// now, the address of the data we want is in RBX
	return eval_ss;
}

member_selection member_selection::create_member_selection(Binary &exp, struct_table& structs, symbol_table& symbols, unsigned int line) {
	/*
	
	create_member_selection
	Creates a member_selection based on a binary expression (operator must be dot or arrow)
	
	The algorithm works, generally, as follows:
		I. Look at the left side
			A.	If the type is 'binary', we need to call this function recursively on it
			B.	If the type is some other valid expression (LValue or Unary) then we look up the information for that struct
		II. Look at the right side
			A.	Ensure it is a correct type (LValue only)
			B.	Look up the symbol within the left-hand struct
			C.	Create a node pointing to this symbol
		III. Finalize our member_selection object and return it

	If the expression we encounter is a dereferenced pointer, we need to get the symbol being dereferenced correctly.
	Further, the compiler also needs to verify that the number of dereferences is actually accessing the right object -- otherwise, we will run into problems.

	@param	exp	The binary dot/arrow expression we are evaluating
	@param	structs	The struct table we need to look into for our struct data
	@param	symbols	The symbol table we need to look into for our symbols
	@param	line	The line number where this expression appears
	
	@returns	A member_selection object containing the data we need

	@throws	A specialized CompilerException if there are any errors

	*/

	// ensure the operator is valid
	if (exp.get_operator() != DOT) {
		throw CompilerException("Expected dot operator in member selection", compiler_errors::OPERATOR_TYPE_ERROR, line);
	}

	member_selection m;

	// todo: allow indexed expressions on LHS

	// first, handle the left hand side
	if (exp.get_left()->get_expression_type() == BINARY) {
		Binary* left = dynamic_cast<Binary*>(exp.get_left().get());
		m = create_member_selection(*left, structs, symbols, line);
	}
	else if (exp.get_left()->get_expression_type() == UNARY) {
		/*

		Unary LHS expressions would be something like:
			(*pointer).member
		where 'pointer' is of the type ptr< T >; in C, this would be equivalent to pointer->member

		If a struct has a pointer-to-struct member, and a member of that struct is accessed, we would have the following in C:
			p1->p2->m
		but SIN doesn't allow this syntactic sugar; instead, we have
			(*(*p1).p2).m
		This will get parsed into:
			Binary
				LHS: Unary
					Operand: Binary
						LHS: Unary
							Operand: LValue
						RHS: LValue
				RHS:
					LValue
		
		*/

		Unary *left = dynamic_cast<Unary*>(exp.get_left().get());
		m = create_unary_node(*left, structs, symbols, line);
	}
	else if (exp.get_left()->get_expression_type() == IDENTIFIER) {
		Identifier* left = dynamic_cast<Identifier*>(exp.get_left().get());
		m = create_lvalue_node(*left, structs, symbols, line);
	}
	else {
		throw InvalidMemberSelectionOperator(line);
	}

	// note a unary expression should never appear on the left hand side, as they all have lower precedences than the dot operator

	// get the struct_info object for the last struct in the chain; this is where we look up the next symbol
	// however, because we may have had pointer types, get the pointed-to struct name
	DataType t = m.last().get_data_type();
	while (t.get_primary() == PTR) {
		t = m.last().get_data_type().get_subtype();
	}

	if (!structs.contains(t.get_struct_name())) {
		throw SymbolNotFoundException(line);
	}
	struct_info& last_struct = structs.find(t.get_struct_name(), line);

	// check to see if the struct has been defined by checking whether its width is known
	if (!last_struct.is_width_known()) {
		throw UndefinedStructAccession(line);	// struct members cannot be accessed if they haven't been defined
	}

	// todo: allow indexed expressions on RHS

	// now, handle the right hand side -- note that dereferenced expressions are forbidden here (only allowed on the left side)
	if (exp.get_right()->get_expression_type() == IDENTIFIER) {
		Identifier* right = dynamic_cast<Identifier*>(exp.get_right().get());
		
		// get the symbol and append it
		try {
			symbol& right_sym = last_struct.get_member(right->getValue());
			m.append(right_sym);
		}
		catch (std::exception& e) {
			throw SymbolNotFoundException(line);
		}
	}
	else if (exp.get_right()->get_expression_type() == UNARY) {
		throw CompilerException("Unary expressions are not allowed on the right-hand side of a member selection expression (e.g., a.*b or a.-b); proper syntax is *a.b and -a.b, respectively", compiler_errors::INVALID_EXPRESSION_TYPE_ERROR, line);
	}
	else {
		throw CompilerException("Invalid expression type on right-hand side of member selection", compiler_errors::INVALID_EXPRESSION_TYPE_ERROR, line);
	}

	// issue a warning if the first member is marked as freed (we can't know for sure -- it may not be freed in the scope we are looking in, so issue a warning, not an error)
	if (m.first().was_freed()) {
		compiler_warning(
			"Symbol '" + m.first().get_name() + "' may have been freed",
			compiler_errors::DATA_FREED,
			line
		);
	}

	return m;
}

void member_selection::append(symbol & to_add)
{
	// appends an element to the list
	this->symbols.push_back(to_add);

	// if the iterator points to the end, then we must update it to point it to the last element
	if (this->it == this->symbols.end()) {
		this->it--;
	}
}

symbol & member_selection::last()
{
	// sets the iterator to the last element and returns it
	if (this->symbols.empty()) {
		throw std::out_of_range("Empty list in member selection object");
	}

	this->it = this->symbols.end();
	this->it--;
	return *this->it;
}

symbol & member_selection::first()
{
	// sets the iterator to the first element and returns it
	if (this->symbols.empty()) {
		throw std::out_of_range("Empty list in member selection object");
	}

	this->it = this->symbols.begin();
	return *this->it;
}

symbol & member_selection::peek_previous()
{
	// peeks the member *before* the current one
	if (this->it == this->symbols.begin()) {
		throw std::out_of_range("Cannot peek before first element in list");
	}

	std::list<symbol>::iterator temp = this->it;
	--temp;
	return *temp;
}

symbol & member_selection::previous()
{
	// decrements the iterator and returns the result
	if (this->it == this->symbols.begin()) {
		throw std::out_of_range("Cannot peek before the first element in list");
	}

	this->it--;
	return *it;
}

symbol & member_selection::peek() {
	// if the iterator isn't at the end, get the next item
	std::list<symbol>::iterator temp = this->it;
	temp++;
	if (temp == this->symbols.end()) {
		throw std::out_of_range("No more members in member selection list");
	}

	return *temp;
}

symbol & member_selection::next() {
	// increment the iterator and return the value at it
	this->it++;
	if (this->it == this->symbols.end()) {
		throw std::out_of_range("No more members in member selection list");
	}

	return *this->it;
}

bool member_selection::is_at_end() {
	// check if we are pointing to the last element
	std::list<symbol>::iterator temp = it;
	++temp;
	return (temp == this->symbols.end());
}

member_selection & member_selection::operator=(member_selection right) {
	/*
	
	operator==
	The overloaded assignment operator, allowing us to initialize member_selection objects with other such objects properly
	
	@param	right	A reference to the right hand member_selection object

	*/

	this->symbols = right.symbols;	// all we really need to do is initialize this list with the other one
	this->it = this->symbols.begin();
	return *this;
}

member_selection::member_selection(Binary & exp, struct_table & structs, symbol_table & symbols, unsigned int line) : member_selection()
{
	*this = member_selection::create_member_selection(exp, structs, symbols, line);
	this->it = this->symbols.begin();
}

member_selection::member_selection()
{
	this->it = this->symbols.begin();
}

member_selection::~member_selection()
{
}
